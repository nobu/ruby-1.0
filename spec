.\" spec -  -*- Indented-Text -*- created at: Tue May 25 15:18:26 JST 1993

* はじめに(なぜRubyか?)

Rubyは「UNIXで手軽にオブジェクト指向プログラミング」をしたいという望み
を実現するために生まれた. そのために必要だと思われた性質は:

    * 文法や機能が単純である.
    * オブジェクト指向プログラミングをサポートする機能を
      持つ言語として設計されている.
    * ターンアラウンドタイムが短い(インタプリタである).
    * OS(UNIX)の機能が簡単に利用できる.
    * スクリプト言語として使える.
    * 処理系がfreeである.

などである. オブジェクト指向言語として一般的であるSmalltalkやC++などは
上の条件の一部を満たしてはいるが, 特に手軽なプログラミングという点に欠
けており, 以上の条件の全てを満たすものではなかった. 一方スクリプト言語
であるPerlや Tclにオブジェクト指向機能を追加したシステムも存在するが, 
これらは「手軽にプログラミング」という性質は満たしてはいても, 逆にオブ
ジェクト指向機能に不備や不満があった. よって, これらの条件を満たす言語
を新たに設計する必要があると考えられた. これらを踏まえて設計されたRuby
の特徴は:

    * インタプリタである.
    * 単純で例外の少ない文法.
    * 十分なオブジェクト指向機能を持つ.
    * できるだけ書きやすい(演算子形式など).
    * ガーベージコレクタがある.
    * 例外処理機能がある.
    * 十分に強力なクラスが組み込まれている.
    * OSをアクセスする機能が提供される.
    * 拡張しやすい.

などがある. RubyはshやPerlを知っている人にとっての常識になるたけ従った
ので, それらの言語からの自然な移行が可能であると思われる. プログラマが
Rubyのオブジェクト指向機能について学べば, より強力なこともできるように
なるだろう.

更にC言語でクラスやメソッドを記述し, 追加することでRubyを更に強力にす
ることができる. 一部のプラットフォームではRubyは動的にオブジェクトファ
イルをリンクできるし, そうでなくてもRubyを再コンパイルして組み込みクラ
スを追加するのは容易である(Perlなどよりもはるかに容易である).

* Rubyの基本

Rubyの基本的な部分は非常に小さく, 文法に例外が少ないので身につけるのは
さほど難しくないだろう.

** コメント

スクリプト言語の習慣にならい, 文字列中以外の'#'から行末まではコメント
と見なす.

** 区切り記号

空白文字(タブとスペース)および改行(\n)が区切り記号となる. ただし,

    a +
    b

のように行が式(文)の途中で終り, 次の行に続くことが明白な場合以外は改行
は文の区切りとして認識される.

** 識別子

アルファベットか`_'で始まり, アルファベット, 数字, `_'の任意の並びは識
別子である. 識別子の長さに制限はない.

** 予約語

予約語は以下の通りである

  break		elsif		module		self		when
  case		end		nil		super		while
  class		ensure		protect		then		yield
  continue	for		redo		undef		__END__
  def		if		resque		unless		__FILE__
  do		in		retry		until		__LINE__
  else		include		return		using

予約語はクラス名, メソッド名, 変数名などに用いることはできない.

** グルーピング

式は括弧によってグルーピングすることができる. 更に括弧内には式の並びも
書ける. 式の並びを記述する場合, 式と式の区切りには改行か ';' を用いる. 
式の並びの値は最後に評価した式の値である. つまり

    (式; 式; ...)

の値は最後に評価した式の値になる.

** リテラル

以下のリテラルがある これらは式である.

   文字列リテラル

        "..."   # バックスラッシュの解釈と変数展開あり
        '...'   # バックスラッシュの解釈なし(\\と\'は解釈する)

        バックスラッシュ記法

                \t      タブ(0x09)
                \n      改行文字(0x0a)
                \r      復帰文字(0x0d)
                \f      改ページ文字(0x0c)
                \b      バックスペース(0x08)
                \a      ベル(0x07)
                \e      エスケープ(0x1b)
		\#	文字`#'そのもの
              \nnn      8進数表記(nは0-7)
              \xnn      16進数表記(nは0-9,a-f)
               \^c      コントロール文字(cはASCII文字)
              \C-c      コントロール文字(同上)
              \M-c      メタ文字(c|0x80)

    正規表現リテラル

             /.../

    正規表現

                 ^      行頭
                 $      行末
                 .      任意の1文字
                \w      英数字. [0-9A-Za-z_]と同じ
                \W      非英数字
                \s      空白文字. [ \t\n\r\f]と同じ
                \S      非空白文字
                \d      数字. [0-9] と同じ
                \D      非数字
                \b      語境界文字(文字クラス外)
                \B      非語境界文字
                \b      後退(0x08)(文字クラス内)
               [ ]      文字クラス指定
                 *      直前の表現の0回以上の繰り返し
                 +      直前の表現の1回以上の繰り返し
             {m,n}      m回からn回の繰り返し
                 ?      0または1回
                 |      選択
               ( )      正規表現をまとめる

        その他に文字列と同じバックスラッシュ記法も有効である.

   数値リテラル

               123      整数
              -123      整数(符合つき数)
             1_234      整数(10進数は`_'を含むことができる)
            123.45      浮動小数点数
            1.2e-3      浮動小数点数
            0xffff      16進整数
              0377      8進整数
                ?a      文字`a'のコード(97)
             ?\C-a      コントロールaのコード(1)
             ?\M-a      メタaのコード(225)
          ?\M-\C-a      メタ-コントロールaのコード(129)

        ?表現では全てのバックスラッシュ記法が有効である.

*** 変数展開

ダブルクォート(`"')で囲まれた文字列と正規表現の中では `#{変数名}'とい
う形式で変数の内容を展開することができる. 変数が変数記号(`$',`@',`%') 
を持つ場合には`#変数名'という形式でも展開できる. 文字`#'に続く文字が 
`{'でないか, 変数でなければ, そのまま`#'として解釈される.

** コマンドの出力

``で囲まれた文字列は, ダブルクォートと同様に展開された後, シェルと同じ
ようにコマンドとして実行され, その実行結果が文字列として与えられる. コ
マンドは評価されるたびに実行される.

** 配列式

配列式は以下の形式である.

    [ 式, ... ]

それぞれの式を評価した結果を含む配列を返す. 要素が0の配列を生成するた
めには空の配列式

    []

を用いる.

** 連想配列式

連想配列とは任意のオブジェクトをキー(添字)として持てる配列である. Ruby 
では連想配列はSmalltalkの用語を借りてDict(辞書)とも呼ばれる. 詳細はク
ラスDictの項を参照されたい. 連想配列を生成する連想配列式は以下の形式で
ある.

    { 式=>式, ... }

それぞれの式を評価した結果をキーと値とする連想配列オブジェクトを返す. 
要素が0の連想配列を生成するためには空の連想配列式

    {}

を用いる.

** 変数参照

変数には4種類あって, その種類は変数名の最初の一文字で決定される. 代入
されていない変数を参照した時の値はnilである.

  クラス変数(定数)

    `%'で始まる変数はクラス変数であり, そのクラスと全てのサブクラスの
    インスタンスから参照できる. この変数への代入はトップレベル, すなわ
    ちメソッドが定義できるレベルでのみ可能である. この変数はクラス間で
    値が共有され, 一度代入するとメソッドからは値を変更することができな
    いので,定数として用いられる.

  インスタンス変数

    `@'で始まる変数はインスタンス変数であり, そのクラスまたはサブクラ
    スのメソッドから参照できる. その寿命はオブジェクトの寿命に等しい.

  グローバル変数

    `$'で始まる変数のスコープはグローバルであり, その寿命はプログラム
    の寿命と等しい.

  クラス名/モジュール名/ローカル変数

    アルファベットまたは`_'で始まる変数は識別子とも呼ばれ, ローカ
    ル変数, クラス名またはモジュール名である.

    初期状態では識別子はクラス/モジュール名とみなされるが(該当するクラ
    スが存在しない場合の値はnil), 代入式の左辺に現れた識別子は,そのス
    コープ内ではローカル変数として見なされ, 同名のクラスやモジュールは
    隠される. この意味で識別子への代入は宣言としての働きも持つ.

        Array       		# 配列クラス Array
        Array = 15		# 代入. 以後Arrayはローカル変数
        print(Array, "\n")	# `15'が出力される

    この宣言はコンパイル時に解釈されるため, 識別子への代入式が実際に実
    行されても, されなくても, 以降のスコープ内ではその識別子はローカル
    変数とみなされる.

        Array       		# 配列クラス Array
        if %FALSE
          Array = 15    	# このコードは実行されないが,
				# 以降Arrayはローカル変数とみなされる.
        end
        print(Array, "\n")  	# `nil'が出力される

    このルールは一見複雑だが, クラス/モジュール名とローカル変数名が重
    複しない限り, 未初期化のローカル変数の値はnilであると考えても差し
    支えはない.

    Rubyの組み込みクラスは大文字のアルファベットで始まる名前がついてお
    り, ユーザもクラス/モジュール名には大文字で始まる識別子を, ローカ
    ル変数名には小文字または`_'で始まる識別子を使うことを強く推奨する.

    ローカル変数の寿命はそのメソッドが終了するまで(トップレベルのロー
    カル変数はプログラムの終了まで)である.

更に疑似変数と呼ばれる特殊な変数が4つある. 

      self   | 現在のメソッドの実行主体
       nil   | Nilクラスの唯一のインスタンス(偽を表す)
    __FILE__ | スクリプトのファイル名(文字列)
    __LINE__ | 現在の行番号

これらの疑似変数は代入によってその値を変更することはできない. これらの
変数への代入は例外を発生させる.

** メッセージ式

オブジェクトにメッセージを送る基本的な構文がメッセージ式であり, その基
本形式は以下の通りである.

    式1.メソッド名(引数...)

        式1を評価して得られるオブジェクトの, 識別子で指定されるメソッ
        ドを呼び出す. 一番最後の引数が'*'に続く(単一の)式である場合, 
        その式を評価した結果(配列である必要がある)を展開して, 引数とし
        て追加する.

        引数が一つもない時には括弧を省略できる.

メソッド名としては任意の識別子を用いることができる. 変数名とは識別子の
名前空間が違うので重複しても構わない.

** 関数式

メッセージ式で, レシーバがselfの場合, レシーバを省略して通常のプログラ
ミング言語における関数のような形式でメソッドを呼び出すことができる. こ
の場合引数が1つもない時でも括弧の省略はできない.

関数形式では`@'で始まる名前を持つメソッドを呼び出すことができる. `@'で
始まるメソッドは関数形式でしか呼び出すことができないため, 該当するクラ
スまたは, そのサブクラスからしか呼ばれないので, プライベートメソッドと
呼ばれる. プライベートメソッドはC++におけるprotected member functionに
該当する.

** スーパークラスのメソッド呼び出し

メッセージ式の特殊なケースとしてスーパークラスのメソッドの呼び出しがあ
る. この形式はメソッドを再定義した時にスーパークラスの定義を利用するた
めに使う.

    super

        現在のメソッドに与えられた引数のままスーパクラスの同名のメソッ
        ドを呼び出す.

    super(引数...)

        引数とともにスーパークラスの同名のメソッドを呼び出す. 一番最後
        の引数が`*'に続く場合は通常のメソッド呼び出しと同様に渡される.

** 演算式

プログラミングの利便のために一部のメソッド呼び出しと制御構造は演算子形
式をとる. Rubyには以下にあげる演算子がある. 上のものほど結合順位が強く, 
同じ列の演算子の結合順位は同じである.

   強   -(unary)  +(unary)  !  ~
        **
        *  /  % 
        +  -
        <<  >>
        &
        |  ^
        >  >=  <  <=
        <=> ==  !=  =~  !~
        &&
        ||
        .. ...
        ::
        =(代入) 自己代入(+=, -=, ..)
   弱   yield

ほとんどの演算式にはメソッド呼び出しとして解釈される(クラス毎に再定義
できる)が, 一部再定義できない特殊なものがある. 再定義できない特殊演算
子は

    	&&(論理積), ||(論理和), =(代入), ...(範囲指定), 
	yield(ブロック呼び出し)

の5つである.
  
上であげた特殊演算子以外の演算子形式はメソッド呼び出しと見なされる.
単項演算子(+, -, !, ~)は

    式1."演算子"()

という形式に, 2項演算子は

    式1."演算子"(式2)

に解釈される. 多項演算子(配列の参照の[])は演算子形式の特別な形として

    recv[arg..]

が,

    recv."[]"(arg..)

と解釈される. 配列要素への代入も同様に

    recv[arg0..] = argn

が,

   recv."[]="(arg0.., argn)

と解釈される.

** 条件式

if, unless, while, untilの条件判断部の式, および特殊演算子`&&', `||',
`...'の両辺の式, 通常演算子`!'の右辺は条件式と呼ばれる. 条件式では文字
列と正規表現リテラルは式「$_=~リテラル」の省略であるとみなされる. 更に
演算子`...'の両辺では整数定数が「$.==定数」の省略と解釈される.

注意: 演算子`!'は特殊演算子ではないので, 再定義を行なう場合に気をつけ
ること. 

	! 文字列リテラル
	! 正規表現リテラル

の形で呼び出されるメソッドの引数は, リテラルの表すオブジェクトではなく, 
上記の比較の結果が与えられる.  このため, 原則的に`!'メソッドは再定義し
ない方が良いと思う.

** 代入

代入には変数に対する代入(真の代入)と, プログラムを簡単にするためのシン
タックスシュガーとしての代入がある. 真の代入は以下の形式である.

    変数 = 式

これは式を評価し, 変数の値として代入する. クラスやモジュールや疑似変数
には代入できない. クラスやモジュールの定義を変更するためにはclass文,
module文を用いる. 代入式は演算子形式をとっているが, メソッドではないの
で再定義することはできない.

シンタックスシュガーとしての代入式は以下のものがある.

  配列要素への代入

    式1[式2,..] = 式n

    式1を評価して得られるオブジェクトに, 式2から式nまでを引数とし
    て, "[]="というメソッドを呼び出す.

  属性代入

    式1.識別子 = 式2

    式1を評価して得られるオブジェクトに対して"識別子="というメソッ
    ドを, 式2を引数として呼び出す.

  自己代入

    式1 op= 式2     # 式1は代入可能でなければならない.

    この形式は内部的に「式1 = 式1 op 式2」と展開され, 実行される. その
    ため式1は2回評価されるので, 副作用がある場合は予想しない結果を呼ぶ
    可能性がある. 自己代入形式はプログラマのタイプ数を減らす目的のため
    に存在する形式である. opとして使える演算子は

        +, -, *, /, %, **, &, |, ^, <<, >>

    の11種類である. 演算子と`='の間にスペースを空けてはいけない.

*** 多重代入

同時に複数の変数に代入を行なうことができる. その形式は以下の通りである.

    変数, [変数,...] = 式 [, 式]

右辺の式が一つしかない場合は, その値を配列として(必要ならばto_aメソッ
ドで配列に変換して), 要素をそれぞれ変数に代入する. それ以外の場合には, 
それぞれの式の値が変数に代入される. 左辺の変数の数と右辺の要素の数が合
わない時には足りない変数には nilが代入され, 余った要素は無視される.

    foo, bar = [1, 2]		# foo = 1; bar = 2
    foo, bar = 1, 2		# foo = 1; bar = 2
    foo, bar = 1		# foo = 1; bar = nil

    foo, bar, baz = 1, 2	# foo = 1; bar = 2; baz = nil
    foo, bar = 1, 2, 3		# foo = 1; bar = 2

** 条件分岐

  if 式1 [then]
    文1 
  [ elsif 式2 [then]
    文2 ]... 
  [ else 
    文n ]
  end [ if ]

    条件判断文. else if でもelifでもなくelsifでifの連続を行なうことに
    注意すること.

  unless 式1 [then]
    文1 
  [ else 
    文2 ]
  end [ unless ]

    式1が偽(nil)を返すか, 式2の評価中に例外が発生した場合に文1を評価
    する.

  式1 && 式2

    式1を評価し, その値が真(nil以外)であれば, 式2を評価する.

  式1 || 式2

    式1を評価し, その値が偽であれば, 式2を評価する.

  式1 ... 式2

    式1が真になるまでは偽を返し, その後は式2が真を返すまでは真を返す. 
    式2が真になれば状態は偽に戻る

  case 式0
  [ when 式1 [, 式2]...
    文1 ]...
  [ else
    文n ]
  end [ case ]

    条件分岐, CのswitchよりもPascalのcaseに似ている. breakで脱出するこ
    とも後ろの文に継続することもないので注意.

    条件の一致は「式n =~ 式0]で行なわれる. つまり,

         case expr0
         when expr1, expr2
           stmt1
         when expr3, expr4
           stmt2
         else
           stmt3
         end

    は以下のif文と等価である.

          _tmp = expr0
          if expr1 =~ _tmp || expr2 =~ _tmp
            stmt1
          elsif expr3 =~ _tmp || expr4 =~ _tmp
             stmt2
          else
             stmt3
          end

** 繰り返し

  while 式
    文
  end [ while ]

    条件が真の間, 文を繰り返し実行する.

  until 式
    文
  end [ until ]
  式1 until 式2

    式が偽(nil)を返すか, 式の評価中に例外が発生する間, 文を繰り返し実
    行する.

** イテレータ

イテレータとは制御構造(特にループ)の抽象化のために用いられるメソッドの
一種である. イテレータの呼び出しは以下の構文で行なわれる.

  do
    文1
  using 変数
    文2
  end [ do ]

    「文2」をブロックとして設定し, 文1のメソッドをイテレータとして評価
    する. 文1のトップレベルのメソッドだけがイテレータとして呼び出され, 
    レシーバを表す式や, 引数の式はイテレータとしては呼び出されない. 文
    1に複数の式があれば各々がイテレータとして順に呼ばれる.

イテレータ内でyield valueが実行されると, その値がdo文で指定された変数
に代入されブロックが実行される. ブロックの実行が終了するとその値は
yield式の値として返される. あるメソッドがイテレータとして呼び出された
かどうかは関数iterator_p()で知ることができる. 中にはEnumerableモジュー
ルのgrepメソッドのようにイテレータとして呼ばれた時と普通のメソッドとし
て呼ばれた時とで動作が異なるメソッドもある.

  for 変数 in 式
    文
  end [ for ]

    式の各要素に対し文を実行する. これは以下のdo文と等価である.

        do (式).each using 変数
          文
        end

    よって式の値のオブジェクトがメソッドeachを持たない場合, forを実行
    すると例外が発生する.

** 例外処理

処理中に予期しない事態が発生した時には例外が発生する. Rubyでは例外を途
中で捕捉して, 再試行したり, 後処理を行なったりすることができる.

  protect
    文1
  [ resque
    文2 ]
  [ ensure
    文3 ]
  end [ protect ]

    文1を実行し, その実行中に例外が発生すればresque節で指定された文2を
    実行する. 更にensure節が存在する時はprotect文を終了する前に必ず(正
    常終了時だけでなく, 例外, return, break, continue, redoなどによる
    脱出でも)文3を実行する.

protect以外に, unless演算子, until演算子は右辺の値を求める時に例外が発
生した場合, 右辺の値として偽を与えられたと見なすので, 暗黙の例外処理を
行なっていることになる.

** 大域脱出

  return [式]

    メソッドの実行を終了する. 

  continue
  redo
  break

    上記3つはループ中で使う.

    continueはもっとも内側のループの次の繰り返しを始める. redoはループ
    のループ条件のチェックを行なわず, 現在の繰り返しをやり直す. break
    はループを脱出する. Cと違い, breakはもっとも内側のループを脱出する
    作用だけを持ち, caseを抜ける作用は持たない.

  retry

    protect文のresque節で使い, protect文を始めから実行する. 例外処理を
    行なってから再試行するのに使う.

  fail([メッセージ])       * これはKernelクラスのメソッドである.

    例外を発生させる. メッセージが与えられた場合には発生したソースファ
    イル名, 行番号を$@にメッセージを$!にセットする.

** イテレータの中でのブロック呼び出し

  yield 式

    イテレータの中でブロックの呼び出しを行なう. yieldを実行したメソッ
    ドがイテレータとして呼び出されていない時には例外が発生する.

** クラス定義

クラスを定義する構文は以下の通りである.

   class クラス名 [ : スーパークラス名 ]
       定義実体
   end [ class ]

値はnil. クラス名は大文字で始まる識別子である. クラス定義のネストはで
きないので他の定義文内ではクラスを定義できない.

** モジュール定義

モジュールを定義する構文は以下の通りである.

   module クラス名
       定義実体
   end [ module ]

モジュール名は大文字で始まる識別子である. クラス同様, モジュール定義も
ネストできない.

** インクルード

クラスにモジュールをインクルードする構文は以下の通りである.

   include モジュール名 [, モジュール名...]

現在の定義中のクラスまたはモジュール(トップレベルではObject)に指定した
モジュールをインクルードする. これによって多重継承をエミュレートできる.

** メソッド定義

通常(特異メソッドでない)メソッド定義の形式は以下の通りである. 通常メソッ
ド定義はネストできないので, メソッド定義文中ではメソッド定義文を再び呼
び出せない.

    def メソッド名 [ ( 引数 [, 引数...][, *引数 ] ) ]
        定義実体
    end [ def ]

メソッド名は識別子または文字列である. 演算子の再定義をする時には文字列
で指定する.  仮引数並びの最後に`*'がある場合, 仮引数より多く与えられた
実引数は, 最後の引数に配列として与えられる(足りない時にはエラー).

** 特異メソッド定義

メソッド定義にはもう一つ特異メソッドの定義がある. 形式は以下の通りであ
る.

   def 式.メソッド名 [ ( 引数 [, 引数...][, *引数 ] ) ]
       定義実体
   end [ def ]

この形式は式の値であるオブジェクトに特異メソッドを定義する. 式の値は
(ビルトインクラスでない)通常オブジェクトか, クラスまたはモジュールであ
る必要がある. 通常メソッド定義とは異なり, こちらはメソッド本体内でもネ
ストして呼び出すことができる.

特異メソッドは特定のオブジェクトにだけ属するメソッドである. よって通常
は継承しえないが, 例外としてクラスの特異メソッドはそのサブクラスにも継
承される. 言い替えればクラスの特異メソッドは他のオブジェクト指向システ
ムにおけるクラスメソッドの働きをする.

** メソッドの別名定義

以下の形式でメソッドに別名をつけることができる.

   def メソッド名1 メソッド名2

別名を付けられたメソッドは, その時点でのメソッド定義を引き継ぎ, 元のメ
ソッドが再定義されても, 古いメソッドが呼び出されたのと全く同じ働きをす
る.

** メソッド定義取り消し

メソッドの定義を取り消すためにはundefを用いる.

   undef メソッド名

識別子または文字列で指定したメソッドの定義を取り消す.

defによる別名定義とundefによる定義取り消しを使うとクラスのインタフェー
スをスーパクラスと独立に変更することができる. ただし, 自分自身にメッセー
ジを送っている場合に注意しないと既存のメソッドが動作しなくなる可能性が
ある.

* Rubyの組み込み機能

Rubyプログラミングの基本はクラス, モジュールとそのメソッドの習得である. 
Rubyには処理系そのものに以下の機能が組み込まれている. ライブラリをロー
ドすることによって機能は増えるが, それらに関してはそれぞれのライブラリ
のドキュメントを参照してもらいたい.

右端に`+'記号のついたメソッドは関数メソッドである.

** 関数

Rubyには厳密な意味では関数はないがKernelクラスのメソッドの一部は(全ク
ラスから関数形式で呼び出せるので), 関数的に用いられる. 関数的に用いら
れるメソッドを以下にあげる. これらのメソッドを再定義する際には互換性を
考えて行なうべきである.

   _exit(status)						+

	プログラムの実行を終了する. 整数statusを終了ステータスとする.
	exit()とは違って, 例外処理などは一切行なわない. fork()の後, 子
	プロセスを終了させる時などに用いる.

   caller                                                       +
   caller(level)                                                +

        スタックフレームから情報を得て, メソッドの呼び出し元のファイル
        名, 行番号, 引数を要素とする配列を返す. levelが与えられた場合
        は現在のスタックフレームよりlevel段上の情報を返す.

   eof()							+

	コマンドラインからの入力がEOFに到達している場合, 真を返す.

   eval(expr)                                                   +

        exprとして与えられた文字列をrubyプログラムとして解釈,実行する.

   exec(command)                                                +

        現在実行しているプロセスを終了して, command文字列で指定される
        別プロセスを起動する.

   exit([status])                                               +

        プログラムの実行を終了する. statusとして整数が与えられた場合, 
        その値をRubyコマンドの終了ステータスとする.  デフォルトは0.

   fail([message])                                              +

        例外を発生させる. メッセージが与えられた場合にはそれをシステム
        変数`$!'にセットし, 発生した位置をシステム変数`$@'にセットする.

   fork()                                                       +

        forkシステムコールを実行し, 子プロセスを生成する. 詳細は
        fork(2)を参照のこと. 親プロセス側では子プロセスのプロセスidを
        返し, 子プロセス側ではnilを返す. 何らかの原因で子プロセスの生
        成に失敗した時には例外が発生する.

   format(format, ...)                                          +

        フォーマットとして与えられた文字列をC言語のsprintfと同じように
        解釈し, 引数を展開した文字列を返す. メソッドsprintf()の別名.

	Rubyにおけるformat指定子の拡張についてはsprintf()の項を参照の
	こと.

   getc()                                                       +

        標準入力から一文字取り出す. 戻り値は読み込んだ文字の文字コード
        (ASCII)を表すFixnumである.

   getenv(name)                                                 +

        nameに該当する環境変数を取り出す.

   gets(pattern, replace)                                       +

        引数として与えられたファイル(なければ標準入力)から一行読み込ん
        で, 読み込みに成功した時にはその文字列を返す. ファイルの終りに
        到達した時にはnilを返す. 行の区切りはシステム変数`$/'によって
        変更できる. 読み込んだ文字列はシステム変数`$_'にもセットされる.

   gsub()                                                       +

        システム変数`$_'の指す文字列に対して置換を行なう. 文字列内で
        patternにマッチする部分を全てreplaceに置き換える. Stringクラス
        のgsubメソッドの解説を参照のこと.

   iterator_p()                                                 +

        メソッドがイテレータとして呼び出された時に真, そうでない時に偽
        を返す述語.

   kill(signal, pid...)                                         +

        pidで指定されたプロセスにシグナルを送る. シグナルはシグナル番
        号か名前で指定する. 負の値を持つシグナル(あるいはシグナル名の
        前に`-')を与えるとプロセスではなくプロセスグループにシグナルを
        送る.

   load(file)                                                   +

        fileをロードする. fileをロードするパスはシステム変数$LOAD_PATH
        で決定される.

   open(file[, mode])                                           +

        fileをオープンして, Fileオブジェクトを返す. ファイル名はオープ
        ンするファイルを示す. ファイル名が`|'で始まる時には続く文字列
        をコマンドとして起動し, パイプラインを生成する.

        コマンド名が"-"である時, open()はRubyの子プロセスを生成し, そ
        の子プロセスとのパイプを返す.

        modeはファイルのアクセスモードを指定する. これは以下のうちのい
        ずれかの文字列である.

            r   読み込み専用. openするファイルはあらかじめ存在している
                必要がある.

            r+  読み書き両用. openするファイルはあらかじめ存在している
                必要がある.

            w   書き込み専用. ファイルが存在していた場合, 長さを0にす
                る. 存在していなければ新たにファイルを作成する.

            w+  読み書き両用. 読み込みが行なえること以外は"w"と同じ働き
                をする.

            a   追加書き込み専用. ファイルはあらかじめ存在している必要
                がある. 書き込みはファイルの最後に追加される.

            a+  読み書き両用. ファイルが存在していなければ新たに作成す
                る. アクセス位置はファイルの最後に初期化される.

        モードが省略された場合のデフォルトは"r"である.

   print(arg1, ..., argn)

        引数を順に出力する. 引数が与えられない時にはレシーバを出力する. 
        文字列以外のオブジェクトが引数として与えられた場合には, 当該オ
	ブジェクトのto_sメソッドによって文字列に変換してから出力される.
        システム変数`$;'(出力フィールドセパレータ)にnilでない値がセッ
        トされている時には, 各引数の間にその文字列を出力する. システム
        変数`$\'(出力フィールドセパレータ)にnil でない値がセットされて
        いる時には, 最後にそれを出力する.

   printf([port, ]format, arg1, ..., argn)                      +

        C言語のprintf()と同じformatに従い引数を文字列に変換し, 出力す
        る. 第1引数がIOのサブクラスのインスタンスであった場合はそのオ
        ブジェクトに対して出力を行なう. デフォルトは$stdoutに出力する.

	Rubyにおけるformat指定子の拡張についてはsprintf()の項を参照の
	こと.

   rand(max)                                                    +

        0からmaxを越えない範囲の整数の乱数を発生する. 戻り値はFixnum.

   require(file)

	fileをロードする. loadとの動作の違いはrequireはロードしたファ
	イルのフルパスを変数$LOAD_FILESに覚えていて, 既にロードしたファ
	イルは再ロードしない点である. 実際にロードした時には%TRUE, 既
	にロードされている時には%FALSEを返す.

   select(reads[, writes[, execpts[, timeout]]])                +

        select(2)を実行する. reads/writes/execptsにはIO(またはそのサブ
        クラス)のインスタンスの配列を与える.  timeoutはFixnum / Float
        / Timeのいずれかで指定する.  戻り値はtimeoutが成立した場合には
        nil, そうでないときは3要素の配列を返し, その各要素が入力/出力/
        例外待ちのオブジェクトを要素として持つ.

   setenv(name, value)                                          +

        nameで指定される環境変数をvalueにセットする.

   sleep([sec])                                                 +

        sec秒だけプログラムの実行を停止する. secが省略された場合, プロ
        セスにSIGALRMが送られない限り, 永久にスリープする. 実際にスリー
        プした秒数を返す.

   sprintf(format, ...)                                         +

        format文字列をC言語のsprintfと同じように解釈し, 引数を展開した
        文字列を返す. メソッドformat()の別名.


	format指定子はC言語のsprintf()が受け付けるもの(ただし, Rubyに
	は unsignedがないので, %uは除く)に加えて, %b, %B, %O, %Xを使う
	ことができる. %bは数値の2進表示, %B, %O, %Xは, それぞれ, 2進,
	8 進, 16進数の表示を行なうが, 負の数の処理の際に2の補数表現で
	はなく, その絶対値表記の先頭に`-'をつけたものを表示する.

   srand([初期値])                                              +

        乱数の初期値を設定し, 古い初期値を返す. 初期値が省略された時に
        はtime(3)の返す値をデフォルトとする.

   sub()                                                        +

        システム変数`$_'の指す文字列に対して置換を行なう. 文字列内で最
        初にpatternにマッチする部分をreplaceに置き換える. Stringクラス
        のsubメソッドの解説を参照のこと.

   syscall(num, arg...)                                         +

	numで指定された番号のシステムコールを実行する. 第2引数以降をシ
	ステムコールの引数として渡す. 引数は文字列または整数でなければ
	ならない.

   system(command)                                              +

        コマンドを実行し, その終了ステータスを返す.

   trap(command, signal...)                                     +

        signalの割り込みがかかった時にcommandを実行する.  signalはシグ
        ナル名かシグナルの番号. commandとしてSIG_IGNまたはIGNOREを指定
        した時にはそのシグナルを無視する(可能ならば). SIG_DFLまたは
        DEFAULTを指定した時はデフォルトの動作を行なう.

   wait()                                                       +

        子プロセスが終了するのを待ち, 終了した子プロセスのpidを返す. 
        子プロセスが一つもなければnilを返す.

   waitpid(pid, flags)                                          +

        特定の子プロセスの終了を待ち, そのプロセスが終了した時に真を返
        す. 子プロセスが存在しないか, ノンブロッキングモードで子プロセ
        スがまだ終了していない時にはnilを返す. waitpid(2)かwait4(2)の
        実装されていないマシンではflagsはいつもnilまたは0でなければな
        らない.

** システム変数

   $!           エラーメッセージ. fail()で設定する.

   $@           エラーが発生した時点のファイル名と行番号が

                    "ファイル:行番号[:メソッド名(あれば)]"

                の形式で格納される.

   $&           最後に成功したパターンマッチ

   $1..$9       最後に成功したパターンマッチでn番目の括弧にマッチした
                値が格納される. 該当する括弧がなければnilが入っている.

   $~           最後のマッチに関する情報. これをセットすると$&や$1..$9
                の値が変化する.

   $=           この変数の値がnilでない時, パターンマッチや文字列の比
                較でアルファベットの大文字小文字を区別しない. デフォル
                トはnil(区別する).

   $/           入力レコードセパレータ. ファイルや文字列に対してeachを
                行なう時の分割文字を指定する. $/に空文字列("")を指定す
                ると段落単位で入力を行ない, nilを指定すると全体を一度
                に読み込む. $/には正規表現は使えない. デフォルトは
                "\n".

   $\           出力レコードセパレータ. この変数に文字列を指定すると
                write()やprint()の度に最後にこの文字列を付加して出力す
                る. デフォルトはnil(なにも追加しない).

   $,		Array:join()のデフォルトの区切り文字列. print()の各引
		数の間に出力される文字列.

   $;		String:split()のデフォルトの区切り文字.

   $.           最後に読んだ入力ファイルの行番号.

   $_           最後にgets()などで読み込んだ文字列.

   $0           rubyスクリプトの名前. この変数に代入するとps(1)の出力
		が変化する.

   $*           rubyスクリプトに与えられた引数. ruby自身に対する引数は
                取り除かれている.

   $$           現在実行中のrubyプロセスのpid.

   $?           最後に実行した子プロセスのstatus.

   $ARGV        $*と同じ.

   $ENV		環境変数にアクセスする連想配列(EnvDict). この変数に対
		して `for'を行なうと変数名と値のペアを与える.

   $FILENAME    関数gets()で現在読み込み中のファイル名.

   $DEBUG	`-d'フラグの状態(真偽値)

   $LOAD_PATH   ファイルをロードする時に検索するディレクトリへのパスを
                含む配列. 起動時にはデフォルト値(コンパイル時に指定す
                る)に加えて, 環境変数RUBYLIBの値とruby起動時の-Iオプショ
                ンで指定された値が追加される.

   $stdin       標準入力
   $stdout      標準出力
   $stderr      標準エラー出力

   $VERBOSE	`-v'フラグの状態(真偽値)

   $VERSION     rubyのバージョンを示す文字列

** システム定数

   %TRUE        1(Fixnum)
   %FALSE       nil

        それぞれ真偽値を表す. 条件判断はnilを偽, それ以外の全ての値を
        真として判断するため, 真偽値を返すメソッドで%TRUE以外の値を返
        すものが存在するので, 比較に用いるのは適切でないことに注意すべ
        きである. 例えば次の式は真にならない.

                (2 < 3) == %TRUE

        メソッド"<"は真の時右辺値を返すので, この場合の値は3であり, 定
        数%TRUEの値1とは異なる. %FALSEに関しては, このような問題は生じ
        ない.

** クラス/モジュール

*** Array(クラス)

数字を添字とした配列のクラスである. 生成は一般的には配列式``[...]''で
行なわれる.

SuperClass: Object

Included Modules: Enumerable

Methods:

   self[nth]
   self[start..end]
   self[start, length]

        配列の要素にアクセスする. 最初の形式では配列のnth番目の要素を
        返し, 2番目の形式ではstart番目の要素からend番目の要素を含む部
        分配列を返す. 3番目の形式ではstart番目からlength個の要素を含む
        部分配列を返す.

   self[nth] = val
   self[start..end] = val
   self[start, length] = val

        配列の要素を変更する. 最初の形式では配列のnth番目の要素をvalに
        変更する. 2番目の形式はstart番目の要素からend番目の要素までを
        valに変更する. 3番目の形式ではstart番目からlength個の要素をval
        に変更する.

        2番目, 3番目の形式ではvalは配列でなければならない.

        例:

          ary = [1, 2, 3, 4, 5]
          ary[0..2] = [0, 0] # 配列の内容は [0, 0, 4, 5]
          ary[1, 0] = [7]    # 配列の内容は [0, 7, 0, 6, 5]

   self + other

        配列の連結. selfとotherの両方の配列の内容を繋げた新しい配列を
        返す.

   self * times

        配列の繰り返し.

   self << obj

        objを配列の末尾に追加する. selfを返すのでC++的に連鎖できる.

   assoc(key)

        連想リスト(2要素の配列を要素とする配列)を検索し, 第1要素がkey
        と等しい("=="で比較する)配列を返す.

   clear

	配列の大きさを0にする.

   delete(item)

	itemと一致する要素を削除する.

   delete_if

        要素を削除するイテレータ. ブロックを評価した値が真の時, 対応す
        る要素を配列から削除する.

   each

        配列の各要素を順に与えるイテレータ.

   fill(val)
   fill(val, start[, length])
   fill(val, start..end)

	配列(の指定された部分)の要素の値をvalに設定する. 2番めの形式で
	lengthが省略された時は配列の終りまでの長さをとる. 指定された部
	分配列が元の配列の範囲を越える時は自動的に拡張される.

   join([sep])

        配列の要素を連結した文字列を返す. 各要素は文字列に変換され, 間
        にsepを挟んで連結される. sepが省略された時にはシステム変数`$,'
        の値が用いられる.

   length

        配列の長さ(要素数)を返す.

   push(obj)

        objを配列の末尾に追加する.

   pack(template)

        配列の内容をtemplate文字列にしたがって, 1つの文字列にパックす
        る. パックした文字列を返す. テンプレートは型指定文字列とその長
        さ(省略時は1)を並べたものである. 長さとして`*'が指定された時は
        「残りのデータ全て」の長さを表す.

        型指定文字は以下のものがある.

          a     ASCII文字列(null文字を詰める)
          A     ASCII文字列(スペースを詰める)
          b     ビットストリング(下位ビットから上位ビット)
          B     ビットストリング(上位ビットから下位ビット)
          h     16進文字列(下位ニブルが先)
          H     16進文字列(上位ニブルが先)
          c     char
          C     unsigned char
          s     sort
          S     unsigned sort
          i     int
          I     unsigned int
          l     long
          L     unsigned int
          n     ネットワークバイトオーダーのshort
          N     ネットワークバイトオーダーのlong
          f     単精度浮動小数点数(機種依存)
          d     倍精度浮動小数点数(機種依存)
          x     ナルバイト
          X     1バイト後退
          @     絶対位置への移動

   pop

        配列の末尾の要素を取り除いて, それを返す.

   rassoc(value)

        連想リスト(2要素の配列を要素とする配列)を検索し, 第2要素が
        valueと等しい("=="で比較する)配列を返す.

   shift

        配列の先頭の要素を取り除いて, それを返す.

   sort

        配列の内容をソートする. イテレータとして呼び出された場合はブロッ
        クを評価した値で要素の大小を決定する. 大きい時に正, 等しい時に
        0, 小さき時に負. 通常のメソッドとして呼び出された場合は各要素
        を`<=>'で比較する.

   to_a

	自分自身を返す. 対称性のために用意されているメソッドであまり面
	白くない.

   unshift(obj)

        objを配列の先頭に追加する.

*** Bignum(クラス)

無限多倍長整数のクラス. 演算の結果がこのFixnumの範囲内である場合には自
動的にクラスはFixnumに変換される. 一般的にRubyプログラムではFixnumと 
Bignumの変換は暗黙のうちに行われるので, 意識する必要は無い. Floatとの
混合に関しては, Bignumより Floatの方がgenericityが高いのにも関わらず,
Bignumの方が, 大きな値を表現できるので, 変換時に桁落ちが生じる可能性が
ある.


SuperClass: Integer

Methods:

   self + other
   self - other
   self * other
   self / other
   self % other
   self ** other

        算術演算. それぞれ和, 差, 積, 商, 剰余, 冪乗を返す.

   ~ self
   self | other
   self & other
   self ^ other

        ビット演算. それぞれビット反転, 論理和, 論理積, 排他的論理和を
        返す.

   self << bits
   self >> bits

        シフト演算. それぞれbitsビットだけ左右にビットシフトを行なう.

   divmod(other)

	商と剰余の2要素の配列を返す.

*** Class(クラス)

クラスのクラス. より厳密に説明するとクラスは特異メソッドを継承するため
に, それぞれメタクラスと呼ばれる名前のないクラスをクラスとして持ち,
Classはそのメタクラスのクラスである(分かったかな?). が, この解説が理解
できなくても, Rubyを使うことに何の支障もない.

SuperClass: Module

Methods:

   attr(name[, public])

	そのクラスのインスタンスに対してnameで指定される属性を定義する. 
	詳しくはModuleのattrメソッドの項を参照のこと.

   new(...)

        クラスのインスタンスを生成する. 多くの場合このメソッドはサブク
        ラスの特異メソッドによってオーバーライドされ, クラスによって引
        数が異なる.

*** Comparable(モジュール)

 比較演算を許すクラスのためのMixin. このモジュールをインクルードするこ
 とによって, `<=>'を定義するだけで他の演算子はその定義を利用して派生で
 きる.

Methods:

   self > other

        selfがotherより大きい時真を返す.

   self >= other

        selfがotherより大きいか等しい時真を返す.

   self < other

        selfがotherより小さい時真を返す.

   self <= other

        selfがotherより小さいか等しい時真を返す.

   between(min, max)

        selfがminとmaxの範囲内にある時真を返す.

*** DBM(クラス)

NDBMファイルをアクセスするクラス. キー, データともに文字列でなければな
らないという制限と, データがファイルに保存されるという点を除いては 
Dictクラスと全く同様に扱うことができる. NDBMを備えていないシステムでは
このクラスへのアクセスは例外を発生させる.

SuperClass: Object

Included Modules: Enumerable

Methods:

   self [key]

        keyをキーとする値を返す.

   self [key]= value

        keyをキーとして, valueを格納する. valueとしてnilを指定すると,
        keyに対する項目の削除となる.

   clear

	DBMファイルの中身を空にする.

   close

        DBMファイルをクローズする. 以後の操作は例外を発生させる.

   delete(key)

        keyをキーとする組を削除する.

   delete_if

	要素を削除するイテレータ. [key, value]という配列を与えて, ブロッ
	クを評価した値が真の時, 該当する項目を削除する.

   each
   each_value

        全てのvalueに対して繰り返すイテレータ.

   each_key

        全てのkeyに対して繰り返すイテレータ.

   each_pair

        [key, value]なる配列を与えるイテレータ.

   includes(key)
   has_key(key)

        keyがデータベース中に存在する時, 真を返す

   has_value(value)

        valueを値とする組がデータベース中に存在する時, 真を
        返す

   keys

        データベース中に存在するキー全てを含む配列を返す.

   length

	データベース中の要素の数を返す. (注意:現在の実現では要素数を数
	えるためにデータベースを全部検索するので, 結構コストが高い. 気
	をつけて使うこと.)

   to_a

	データベース中のkey-valueペアを要素とする配列を返す.

   values

        データベース中に存在する値全てを含む配列を返す.

Single Methods:

   open(dbname[, mode])

        dbnameで指定したデータベースをモードをmodeに設定してオープンす
        る. modeの省略値は0666である. modeとしてnilを指定するとデータ
        ベースが既に存在しない時には新たにオープンせず, nilを返す.

*** Dict(クラス)

辞書あるいは連想配列. 任意のオブジェクトを添字とできる配列のクラスであ
る. Hashという名前でもアクセスできる. 連想配列オブジェクトの生成は一般
的には連想配列式``{a=>b,..}'' で行なわれる.

SuperClass: Object

Included Modules: Enumerable

Methods:

   self [key]

        keyをキーとする値を返す.

   self [key]= value

        keyをキーとして, valueを格納する. valueとしてnilを指定するとそ
        のkeyに対する項目の削除となる. つまり, Dictは値としてnilを持つ
        ことはできない.

   clear

	連想配列を空にする.

   delete(key)

        keyをキーとする組を削除する.

   delete_if

	要素を削除するイテレータ. [key, value]という配列を与えて, ブロッ
	クを評価した値が真の時, 該当する項目を削除する.

   each
   each_value

        全てのvalueに対して繰り返すイテレータ.

   each_key

        全てのkeyに対して繰り返すイテレータ.

   each_pair

        [key, value]なる配列を与えるイテレータ.

   includes(key)
   has_key(key)

        keyが辞書中に存在する時, 真を返す

   has_value(value)

        valueを値とする組が辞書中に存在する時, 真を返す

   keys

        辞書中に存在するキー全てを含む配列を返す.

   length

	辞書中の要素の数を返す.

   to_a

	辞書中のkey-valueペアを要素とする配列を返す.

   values

        辞書中に存在する値全てを含む配列を返す.

Single Methods:

   new

        新しい(空の)辞書オブジェクトを返す.

*** Directory(クラス)

ディレクトリ内の要素を順に返すディレクトリストリーム操作のためのクラス. 
Dirという名前でもアクセスできる.

SuperClass: Object

Included Modules: Enumerable

Methods:

   close

        ディレクトリストリームをクローズする. 以後の操作は例外を発生さ
        せる.

   each

        ディレクトリ内の各要素を順に与えるイテレータ.

   getwd
   pwd

        カレントディレクトリを返す.

   rewind

        ディレクトリストリームを先頭にリセットする.

   seek(pos)

        ディレクトリストリームの位置をposに設定する.

   tell

        ディレクトリストリームの現在の位置を返す.

Single Methods:

   chdir(path)

        カレントディレクトリをpathに変更する.

   chroot(path)

        プロセスのルートディレクトリを変更する, 同名のシステムコールと
        同じ働きをする. この操作は実効uidがスーパユーザである時だけに
        制限されている. ルートディレクトリを元に戻す(ルートディレクト
        リを上方に変更する)方法は提供されていない.

   mkdir(path[, mode])

        modeで指定されたモードを持つディレクトリpathを作成する. モード
        はumaskによって修正される. modeのデフォルト値は0777.

   open(path)

        pathに対するディレクトリストリームをオープンする.

   rmdir(path)

        pathで指定されたディレクトリを削除する. ディレクトリは空である
        必要がある.

*** Enumerable(モジュール)

要素に対する繰り返しを行なうクラスのためのMixin. このモジュールをイン
クルードするためには, メソッド`each'を定義する必要がある.

Methods:

   collect

        各要素に対してブロックを評価した結果を全て含む配列を返す

   find

        要素の対してブロックを評価した値が真になった最初の要素を返す.

   find_all

        各要素に対してブロックを評価した値が真であった要素を全て含む配
        列を返す.

   grep(pattern)

        「pattern =~ 要素」が成立する全ての要素を含む配列を返す. イテ
        レータとして用いられた時は上記の条件の成立した要素に対してブロッ
        クを実行する.

   includes(val)

	valと`=='の関係にある要素を持つ時, 真を返す.

   index(val)

	valと`=='の関係にあるオブジェクトが何番目に現れたかを返す. 一
	番最初の要素が0になる. 要素が存在しない時にはnilを返す. 順序の
	ないクラスに対してはあまり意味がない.

   min

	最小の要素を返す. 各要素が`<=>'メソッドを持つことを暗黙のうち
	に仮定している.

   max

	最大の要素を返す. 各要素が`<=>'メソッドを持つことを暗黙のうち
	に仮定している.

   reverse

        全ての要素を逆順に並べた配列を返す.

   sort

        全ての要素をソートした配列を返す.

*** EnvDict(クラス)

環境変数を操作するためのクラス. システム変数$ENVに唯一のインスタンスが
代入されている.

SuperClass: Object

Included Modules: Enumerable

Methods:

   [name]

	環境変数の値を返す.

   [name]= val

	環境変数の値をvalに設定する. valとしてnilを指定した場合には, 
	該当する環境変数を削除する.

   delete(name)

	環境変数を削除する.

   each

	環境変数の名前と値のペアを与えるイテレータ.

*** Etc(モジュール)

/etcディレクトリ以下の情報を得るためのモジュール. クラスにインクルード
して使うこともできる.

Methods:
Single Methods:

   getlogin

	自分のlogin名を返す. これが失敗した場合はgetpwuid()を用いると
	良い.

   getpwnam(name)

	/etc/passwdファイル(あるいはDBMファイルやNISデータベース)を検
	索し, nameの名前を持つpasswdエントリを返す. 戻り値はpasswd構造
	体で以下のメンバを持つ.

	  struct passwd
	    name 	# ユーザ名(文字列)
	    passwd	# パスワード(文字列)
	    uid		# ユーザID(整数)
	    gid		# グループID(整数)
	    gecos	# gecosフィールド(文字列)
	    dir		# ホームディレクトリ(文字列)
	    shell	# ログインシェル(文字列)
	    # 以降のメンバはシステムによってはないものもある
	    change	# パスワード変更時間(整数)
	    quota	# クォータ(整数)
	    age		# エージ(整数)
	    class	# ユーザアクセスクラス(文字列)
	    comment	# コメント(文字列)
	    expire	# アカウント有効期限(整数)	    
	  end

	詳細はgetpwnam(3)を参照のこと.

   getpwuid([uid])

	uidをユーザIDとするpasswdエントリを返す. 戻り値はgetpwnam()と
	同様である. 引数を省略した場合にはgetuid()の値を用いる. 詳細は
	getpwuid(3)を参照のこと.

   getgrgid(gid)

	/etc/groupファイル(あるいは…getpwnam参照)を検索し, gidをグルー
	プIDとするグループエントリを返す. 戻り値はgroup構造体で以下の
	メンバを持つ.

	  struct group
	    name 	# グループ名(文字列)
	    passwd	# グループのパスワード(文字列)
	    gid		# グループID(整数)
	    mem		# グループメンバ名の配列
	  end

	詳細はgetgrgid(3)を参照のこと.

   getgrnam(name)

	nameという名前のグループエントリを返す. 戻り値はgetgrgid()と同
	様である. 詳細はgetgrnam(3)を参照.

   group

	全てのグループエントリを順にアクセスするためのイテレータ.

   passwd

	全てのpasswdエントリを順にアクセスするためのイテレータ.

*** File(クラス)

ファイルアクセスのためのクラス. 関数メソッドopen()で生成される. また,
このクラスの特異メソッドとしてtestのファイルテスト演算子相当のメソッド
が定義されている.

SuperClass: IO

Methods:

   atime

        ファイルの最終アクセス時刻を返す.

   ctime

        ファイルの最終ステータス変更時刻を返す.

   chmod(mode)

        ファイルのパーミッションを変更する(cf chmod(2)).

   chmod(owner, group)

        ファイルの所有者とグループを変更する(cf chown(2)).  nilか-1を
        指定することによって所有者やグループを現在のまま変えないでおく
        ことができる.

   eof

        ファイルの終端に到達した時に真を返す.

   lstat

        ファイルに関するStat構造体を返す. lstatはファイルがシンボリッ
        クリンクであればリンクそのものに関するStat構造体を返す. 構造体
        の内容についてはstat を参照のこと.

   mtime

        ファイルの最終修正時刻を返す.

   rewind

        ファイルのファイルポインタの位置を先頭に移動する.

   path

        ファイルのパス名を返す.

   seek(offset, ptrname)

        ファイルのファイルポインタの位置をoffsetに移動する.  ptrnameは
        0, 1, 2のいずれかであって, それぞれファイルの先頭, 現在位置, 
        ファイルの終端のうちのいずれかからの相対を示す.

   stat()

        ファイルに関するStat構造体を返す(Struct を参照).

	  struct stat
	    dev	 	# ファイルの存在するデバイス
	    ino		# ファイルのi-node番号
	    mode	# モード
	    nlink	# ハードリンクの数
	    uid		# 所有者のユーザID
	    gid		# 所有者のグループID
	    rdev	# デバイスのID(スペシャルファイルのみ)
	    size	# ファイルサイズ(byte数)
	    blksize	# ファイルシステムにおいて適切なブロックサイズ
	    blocks	# ブロック数
	    atime	# 最終アクセス時間
	    mtime	# 最終更新時間
	    ctime	# 最終状態変更時間
	  end

	詳細な説明はfstat(2)を参照のこと. システム上で定義されている
	stat構造体に該当するメンバがない場合は0が設定されている.

   tell

        ファイルの現在のファイルポインタの位置を返す.

   truncate(length)

        ファイルを切り捨てて最大lengthバイトにする. ファイルはwriteモー
        ドでオープンされていなければならない.

Single Methods:

   atime(filename)

        filenameの最終アクセス時刻を返す.

   b(filename)

        filenameのファイルがブロックスペシャルファイルである時, 真を返
        す.

   c(filename)

        filenameのファイルがキャラクタスペシャルファイルである時, 真を
        返す.

   ctime(filename)

        filenameの最終ステータス変更時刻を返す.

   chmod(mode, path, file...)

        ファイルのパーミッションを変更する(cf chmod(2)).

   chown(owner, group, file...)

        ファイルの所有者とグループを変更する(cf chown(2)). nilか-1を指
        定することによって所有者やグループを現在のまま変えないでおくこ
        とができる.

   executable(filename)
   x(filename)

        filenameのファイルが実行可能の時, 真を返す.

   exists(filename)
   e(filename)
   a(filename)

        filenameのファイルが存在する時, 真を返す.

   G(filename)

        filenameのファイルのgidが実効グループのgidと同じ時, 真を返す.

   isdirectory(filename)
   d(filename)

        filenameがディレクトリの時, 真を返す.

   isfile(filename)
   f(filename)

        filenameのファイルが通常ファイルの時, 真を返す.

   islink(filename)
   l(filename)

        filenameのファイルがシンボリックリンクである時, 真を返す.

   ispipe(filename)
   p(filename)

        filenameのファイルが名前つきパイプ(FIFO)である時, 真を返す.

   issocket(filename)
   S(filename)

        filenameのファイルがソケットである時, 真を返す.

   link(old, new)

        oldへのハードリンクnewを生成する. link(2)と同じ制限がある.

   mtime(filename)

        filenameの最終修正時刻を返す.

   owned(filename)
   O(filename)

        filenameのファイルを実効ユーザが所有している時, 真を返す.

   readable(filename)
   r(filename)

        filenameのファイルを読みとり可能の時, 真を返す.

   readlink(path)

        シンボリックリンクpathの内容を文字列として返す.

   rename(from, to)

        ファイル名fromをtoに変更する. rename(2)参照. 既にtoという名前
        のファイルが存在する時にはまずそのファイルが削除される.

   R(filename)

        filenameのファイルを実uid/gidで読みとり可能の時, 真を返す.

   setuid(filename)
   u(filename)

        filenameのファイルのsetuidビットがセットされている時, 真を返す.

   setuid(filename)
   g(filename)

        filenameのファイルのsetuidビットがセットされている時, 真を返す.

   size(filename)
   s(filename)

        filenameのファイルが存在する時, ファイルの大きさを返す. 存在し
        ない時はnilを返す.

   sticky(filename)
   g(filename)

        filenameのファイルのstickyビットがセットされている時, 真を返す.

   symlink(old, new)

        oldへのシンボリックリンクnewを生成する.

   truncate(path, length)

        pathで指定されたファイルを切り捨てて最大lengthバイトにする.

   unlink(file...)

        ファイルを削除する. ディレクトリの削除にはDir.rmdirを使うこと.

   utime(atime, mtime, file...)

        ファイルのアクセス時刻をatimeに, 修正時刻をmtimeに設定する. 
        atime, mtimeは数またはTimeクラスのインスタンスでなければならな
        い.

   writable(filename)
   w(filename)

        filenameのファイルが実uid/gidで書き込み可能の時, 真を返す.

   W(filename)

        filenameのファイルが書き込み可能の時, 真を返す.

   z(filename)

        filenameのファイルが存在し, 大きさが0である時, 真を返す.

*** Fixnum(クラス)

31bit整数のクラス. builtin classである. このクラスはpointer内の即値で
あるためcall by valueで呼び出される点が特徴的である(他のクラスはcall
by reference). 演算の結果が31bitを越える場合には自動的にBignum(無限多
倍長整数)に拡張される.

イテレータupto(), downto(), step()は繰り返しのために用いられ, 一般に
Rangeクラスを用いるより高速である.

SuperClass: Integer

Methods:

   self + other
   self - other
   self * other
   self / other
   self % other
   self ** other

        算術演算. それぞれ和, 差, 積, 商, 剰余, 冪乗を返す.

   ~ self
   self | other
   self & other
   self ^ other

        ビット演算. それぞれビット反転, 論理和, 論理積, 排他的論理和を
        返す.

   self << bits
   self >> bits

        シフト演算. それぞれbitsビットだけ左右にビットシフトを行なう.

   self .. max

        範囲指定. self から maxまでの範囲オブジェクトを返す.

   downto(min)

        イテレータ. selfからminまで下向きに繰り返す.

   id2name

	整数値をIDだとみなして, 相当する文字列を返す. 相当する文字列が
	存在しない場合はnilを返す.

   step(max, step)

        イテレータ. selfからmaxまでstepずつ変化しながら, 繰り返す.

   to_f

        selfをFloatに変換したものを返す.

   to_i

        selfをそのまま返す.

   upto(max)

        イテレータ. selfからmaxまで繰り返す.

*** Float(クラス)

 浮動小数点数のクラス.

SuperClass: Numeric

Methods:

   self + other
   self - other
   self * other
   self / other
   self % other
   self ** other

        算術演算. それぞれ和, 差, 積, 商, 剰余, 冪乗を返す.

   self == other
   self > other

        比較演算.

   coerce(num)

        numをfloatに変換する. ただし現時点でFloatが理解できる他の数は
        Fixnumだけである.

   to_f

        selfをそのまま返す.

   to_i

        floatを整数に変換した結果を返す.

Single Methods:

   new(float)

	floatと同じ値を持つ新しいFloatオブジェクトを返す.

*** GC(モジュール)

Ruby組み込みのgarbage collectorの制御を行なうためのモジュール. このモ
ジュールのメソッドをを用いることによって, 一時的にGCを止めたり, GCの起
きるタイミングを制御したりできる.

更にgcは始まる時にこのモジュールのstart_hookメソッドを, 終った時には
end_hookメソッドを呼び出すため, これらメソッドを定義することによって
hookをかけることができる.

Methods:

   garbage_collect                                              +

        GCを開始する. 「GC.start」と同義.

Single Methods:

   disable

        GCを禁止する.

   enable

        GCを許可する.

   start

        GCを開始する.

*** Integer(クラス)

整数クラス. 実際はその大きさによってFixnumとBignumいう二つのサブクラス
で実現されている. Integerはそれらのスーパークラスとなる抽象クラスであ
る. Rubyではほとんどの場合, FixnumとBignumの区別は必要なく, 相互の変換
は自動的に行なわれる. 整数をビット列だとみなす場合には, 無限の長さをも
つビット列と考えて構わない.

SuperClass: Numeric

Methods:

   self[idx]

	整数のidxビット目がセットされていれば1, セットされていなければ
	0を返す.

   chr

	その数をコードとする文字だけを含む1文字の文字列を返す. 一般に
	長さ1以上の文字列について, 次の関係が常に成立する.

		str[0].chr == str[0,1]

	整数が文字の範囲内(0..255)になければ例外が発生する.

   is_integer

	いつも真を返す.

*** IO(クラス)

入出力のための基本クラス.

SuperClass: Object

Included Modules: Enumerable

Methods:

   self << object

        objectを出力する. objectが文字列でない時にはメソッドto_sを用い
        て文字列に変換する. selfを戻り値とするので, C++のような`<<'の
        連鎖を使える.

        例:

            $stdout << 1 << " is a " << Fixnum

   close

        入出力ポートをクローズする. 以後のこのオブジェクトに対する入出
        力操作はエラーになる.

   each

        一行ずつ読み込んでくるためのイテレータ. 行の区切りはシステム変
        数`$/'によって変更できる. 読み込んだ文字列はシステム変数`$_'に
        もセットされる.

   each_byte()

        一文字ずつ読み込んでくるためのイテレータ. 文字は文字コードを表
        すFixnumである.

   fileno

        IOオブジェクトが使っているファイルディスクリプタ(Fixnum)を返す.

   flush

        バッファをフラッシュする.

   getc

        一行読み込んで, 読み込みに成功した時にはその文字列を返す. ファ
        イルの終りに到達した時にはnilを返す. 関数的メソッドのgetc()は
        $stdin.getcと同じ意味である.

   gets

        一行読み込んで, 読み込みに成功した時にはその文字列を返す. ファ
        イルの終りに到達した時にはnilを返す.

   isatty

        入出力ポートがttyである時, 真を返す.

   puts(obj)

        objを出力する. 「self << obj」と同じ意味である.

   read([length])

        lengthバイト読み込んで, その文字列を返す. lengthが省略された時
        には, 全てのデータを読み込む.

   sync

	現在の出力同期モードを真偽値で返す. 同期モードが真の時は出力関
	数の呼出毎にバッファがフラッシュされる.

   sync=(newstate)

        出力同期モードを設定する.

   sysread(length)

        stdioを経由せずにread(2)を用いて入力を行なう. 入力されたデータ
        を含む文字列を返す. ファイルの終りに到達した時にはnilを返す. 
        read(2)の性質により必ずlengthバイトの文字列が読み込まれるわけ
        ではない. gets()やgetc()などstdioを経由するメソッドと混用する
        ことはバッファリングの不整合などで, 思わぬ動作をすることがある.

   syswrite(str)

        stdioを経由せずに, wirte(2)を用いて出力を行なう. このメソッド
        はバッファリングなどstdioがしてくれることは一切行なわない. 
        print()やprintf()とsyswrite()を混用するのは推奨できない.

   write(str)

        strを出力する. 出力したバイト数を返す.

Single Methods:

   default

	printやprintfのデフォルトの出力先を返す. 初期値は$stdout.

   default=

	デフォルトの出力先を指定する.

*** Kernel(クラス)

全てのクラスの基底クラス. Ruby組み込みの全ての関数的メソッドはこのク
ラスで定義されている.

SuperClass: なし

Methods:

   ! self

        否定. Non-nilのオブジェクトの場合常に偽(nil)を返す. このメソッ
        ドはNilクラスでは再定義され真を返す.

   equal(other)
   self == other

        オブジェクトの一致判定. レシーバと引数の引数が一致する時, 真を
        返す. Kernelクラスの定義では双方のオブジェクトが同一の時真を返
        す. "=="メソッドは各オブジェクトの性質に応じて再定義する必要が
        ある. "=="メソッドを再定義した時には, hashメソッドもそれに合わ
        せて再定義する必要がある.

        equal()メソッドは"=="メソッドの別名で, "=="を再定義した後でも
        オブジェクトの同一性判定を行なうために用いられる. よって
        equal()メソッドはサブクラスで再定義するべきではない.

   self != other

        "=="の否定. 内部で"=="メソッドを呼び出しているので, こちらは再
        定義する必要はない.

   self =~ other

        マッチ. デフォルトは"=="と同じである. "=~"はcaseの比較にも用い
        られる.

   !~

        "=~"の否定. 内部で"=~"メソッドを呼び出しているので, 再定義する
        必要はない.

   self :: other

        selfとotherを要素とする長さ2の配列を返す. 配列を生成するという
        意味で [self, other]と同じ働きをするが, こちらの方がわずかに効
        率が良い. この演算子は右結合であるので, a::b::c は (a::(b::c))
        と解釈される.

   is_nil

        オブジェクトがnilであるかどうか. Kernelクラスの定義では真を返
        す. Nilクラスで再定義されている.

   id

        各オブジェクトに対して一意のFixnumを返す. が, Fixnumは自分自身を返
        すので, idが一致しても同じオブジェクトであることは保証されない.
        つまり,

		obj1.id == obj2.id

	が成立しても, どちらかがFixnumであれば, obj1とobj2が同じである
	とは限らない. ただし, 両方がFixnumでないことが保証できれば, 2
	つのオブジェクトが同一であることは確実である.

   hash

        オブジェクトのハッシュ値(Fixnum)を返す. Dictクラスでキーとなる
        オブジェクトを格納するのに用いられている.「A == B」が成立する
        時は必ず「A.hash == B.hash」が成立する必要があるので, "=="を再
        定義した時にはこちらもそれに合わせて再定義すること.

*** Math(モジュール)

浮動小数点演算をサポートするクラス. Mathモジュールは同じ定義のメソッド
と特異メソッドとの両方が定義されているので, 特異メソッドを呼び出して使
う使い方と, クラスにインクルードして使う使い方との両方ができる.

  例:

        pi = Math.atan2(1, 1) * 4;
        include Math
        pi2 = atan2(1, 1)

Methods:
Single Methods:

   atan2(x, y)

        π〜-πの範囲でX/Yのアークタンジェントを返す.

   cos(x)
   sin(x)
   tan(x)

        ラジアンで表されたxの三角関数の値を返す.

   exp(x)

        xの指数関数の値を返す.

   log(x)

        xの自然対数を返す.

   log10(x)

        xの常用対数を返す.

   sqrt(x)

        xの平方根を返す. xの値が負である時には例外を発生させる.

   cbrt(x)

        xの立方根を返す.

*** Module(クラス)

モジュールのクラス.

SuperClass: Object

Methods:

   attr(name[, public])						+

	そのモジュールをインクルードしたクラスのインスタンスに対して 
	nameで指定される属性を付加し, 属性に対するアクセスメソッドを定
	義する. attr("attr")は以下に示すコードとほぼ同義である.

	  def attr; @attr; end

	省略可能な第2引数publicが与えられて, かつその値がnilでない時に
	は, その属性には属性設定メソッドも用意され, 外部から代入可能に
	なる. attr("attr", %TRUE)は以下のコードとほぼ同義である.

	  def attr; @attr; end
	  def attr=(val); @attr = val; end

	属性を構成するメソッドを再定義することによって, アクセス時の動
	作を変更できる. 例えば

	  attr("test", %TRUE)
	  def test=(val)
	    print("test was ", @test, "\n")
	    print("and now is ", @test = val, "\n")
	  end

	のように設定時に属性の値を表示するようなことが可能である. attr
	はアクセスメソッドがすでに定義されている場合は, デフォルトのア
	クセスメソッドを定義しない.

   to_s

        モジュールの文字列表現を返す. モジュールの場合の文字列表現はモ
        ジュール名である.

*** Nil(クラス)

偽を表すオブジェクトnilのクラス. 偽変数(の値)nilはNilクラスの唯一のイ
ンスタンスである.

SuperClass: Kernel

Methods:

   self + other

	otherが整数, 浮動小数点数, 文字列, 配列である時, otherを返す.

   ! self

        常に真を返す.

   is_nil

        常に真を返す.

*** Numeric(クラス)

数一般の性質を表す抽象クラス.

SuperClass: Object

Included Modules: Comparable

Methods:

   + self

        オブジェクトselfそのものを返す

   - self

        「0 - self」の値を返す. サブクラスでより効率的に再定義されるこ
        とが期待される.

   abs

	絶対値を返す.

   divmod(other)

	商と剰余の2要素の配列を返す.

*** Object(クラス)

全ての通常クラスのスーパクラス. このクラスのサブクラスでないクラスは
KernelとNilだけである.

SuperClass: Kernel

Methods:

   is_member_of(class)

        オブジェクトselfがクラスclassのインスタンスである時,真を返す.

   is_kind_of(class)

        オブジェクトselfがクラスclassかそのサブクラスのインスタンスで
        ある時, 真を返す.

   clone

        オブジェクトの複製を作る. Fixnum以外のクラスの場合, 恐らくは
        「obj.eqaul(obj.clone)」は偽であるが, 多くの場合「obj ==
        obj.clone」は真である.

   to_s

        オブジェクトの文字列表現を返す. このメソッドは内部的にprint()
        やformat()メソッドで用いられている.

   to_a

	オブジェクトを配列に変換する. カーネルクラスで定義されているデ
	フォルトは, そのオブジェクト自身を含む1要素の配列を返す.

*** Process(モジュール)

プロセスに関する操作を行なうためのモジュール. Mathモジュールと同様に全
てのメソッドは特異メソッドとしても通常のメソッドとしても使える. 
Processはプロセスオブジェクトのクラスではなくて, プロセス操作のメソッ
ドをまとめたものであることに注意すること.

Methods:
Single Methods:

   euid

	プロセスの現在の実効UIDを返す.

   euid=(uid)

	プロセスの現在の実効UIDをuidにセットする.
	
   getpgrp([pid])

	pidで指定されたプロセスが現在所属しているプロセスグループのid
	を返す. pidを省略した時とpidに0を与えた時は現在実行しているプ
	ロセスを対象にする.

   getpriority(which, who)

	whichとwhoで指定されるプロセス, プロセスグループ, ユーザの現在
	の優先順位を返す. 詳細はgetpriority(2)を参照. Processモジュー
	ルではwhichとして指定できる定数%PRIO_PROCESS, %PRIO_PGRP,
	%PRIO_USERが定義されている.

   pid

	プロセスのプロセスIDを返す. これはシステム変数`$$'の値と同じで
	ある.

   ppid

	親プロセスのプロセスのプロセスIDを返す. UNIXでは直接の親プロセ
	スが終了した場合, 親プロセスのpidは1(initのpid)になる.

   setpgrp(pid, pgrp)

	pidで指定されたプロセスのプロセスグループをpgrpにする. pidに0
	を与えると現在実行中のプロセスを対象にする.

   setpriority(which, who, prio)

	whichとwhoで指定されるプロセス, プロセスグループ, ユーザの現在
	の優先順位をprioに設定する. 詳細はsetpriority(2)を参照のこと.

   uid

	プロセスの現在の実UIDを返す.

   uid=

	プロセスの現在の実UIDをuidにセットする.

*** Range(クラス)

範囲オブジェクトのクラス. 範囲オブジェクトは`..'演算子によって生成され, 
一般的には以下のような使い方をする

        for i in 1..5
          ...
        end

しかし, この場合は以下の方が速い.

        do 1.upto(5)
          ...
        end

範囲オブジェクトを生成する`..'演算子の両辺はComparableを含むクラスのイ
ンスタンスであれば何でも構わない. 範囲は始点と終点を含むことに注意する
こと.

SuperClass: Object

Included Modules: Enumerable

Methods:

   self =~ other

        selfがotherと同じクラスに対する範囲オブジェクトで, その範囲内
        にotherがある時(start <= other <= end),真を返す. これはcase文
        で範囲指定する時に便利である.  例えば

            case i
              when 1, 3..5
                ...
            end case

        のようなコードを書くことができる.

   each

        範囲内に存在するオブジェクトを与えるイテレータ. 主にfor文のた
        めに用いられる.

   end

        範囲の終点を返す

   start

        範囲の始点を返す.

*** Socket(クラス)

SuperClass: BasicSocket

ソケットそのものに対するシステムコールレベルのアクセスを提供するクラス.
Perlのソケットに対するアクセスと同レベルの機能を提供している. このクラ
スではソケットアドレスはpackされた文字列で, 指定する. UDPソケットはこ
のクラスを使って利用する.

Methods:

   accept

	新しい接続を受け付けて, 新しい接続に対するソケットを返す.
	accept(2)を参照.

   bind(addr)

	bind(2)と同じ働きをする. addrはpackされたソケットアドレス構造
	体である.

   connect(addr)

	connect(2)と同じ働きをする. addrはpackされたソケットアドレス構
	造体である.

   listen(backlog)

	listen(2)と同じ働きをする.

   recv(len, flags)
   send(mesg, flags[, to])
   sysread(len)

Single Methods:

   open(domain, type, protocol)
   new(domain, type, protocol)

	新しいソケットを生成する. domain, type, protocolはインクルード
	ファイルで定義されている定数値で指定する. domainとtypeに関して
	は, 文字列で指定できるが, すべてをカバーしている保証はない.

   socketpair(domain, type, protocol)

	ソケットのペアを生成し, 2要素の配列として返す. 引数の指定は
	openと同じである.
   
*** Regexp(クラス)

正規表現のクラス. 正規表現のリテラルは/.../という形式で表すが, 動的に
生成するためには

        Regexp.compile(文字列)

とする. ただし, Stringクラスの`=~'を始めとして多くのメソッドは正規表現
の替わりに文字列が与えられた時には内部的に正規表現を生成するので, 生成
コストを節約したいと思う時以外は明示的に生成したいと思うことは少ないは
ずだ.

SuperClass: Object

Methods:


   self =~ string

        正規表現が文字列にマッチした場合, マッチした位置を返す. マッチ
        しない場合はnilを返す.

   ~ self

        「$_ =~ self」と同義.

Single Methods:

   complie(string)

        文字列を正規表現に変換したオブジェクトを返す.

*** BasicSocket(クラス)

ソケットを表す抽象クラス. 具体的なソケット操作はサブクラスで定義される.
例えばインターネットドメインの場合はTCPsocketを用いる.

SuperClass: IO

Methods:

   getopt(level, optname)

	ソケットのオプションを取得する. getsockopt(2)を参照のこと. 取
	得したオプションの内容を含む文字列を返す.

   getpeername

	接続の相手先のソケットの情報を得る. パックされたsockaddr構造体
	をベタにダンプした文字列が返される. getpeername(2)を参照のこと.

   getsockname

	ソケットの情報を得る. パックされたsockaddr構造体をベタにダンプ
	した文字列が返される. getsockname(2)を参照のこと.

   setopt(level, optname, optval)

	ソケットのオプションを設定する. setsockopt(2)を参照のこと.

   shutdown(how)

	ソケットの以降の接続を終了させる. howが0である時, 以降の受信が,
	howが1である時は, 以降の送信が拒否される. howが2の時には, それ
	以降の送信, 受信ともに拒否される.

*** String(クラス)

文字列クラス. Rubyの文字列はヌルターミネートではないので, バイナリデー
タも扱える. 従ってどちらかというと単なる文字列というよりバイト列である. 
その思想に基づいて, 正規表現に関するメソッド以外は2byte系の文字を意識
していない. これは作者の手抜きではなく意図的にそうしているのである(信
じてくれ).

SuperClass: Object

Included Modules: Comparable, Enumerable

Methods:

   self + other

        文字列の連結. 連結された文字列を返す.

   self * times

        文字列の繰り返し. 例えば

            "x" * 4 == "xxxx"

        である.

   self == other
   self > other

        文字列の比較. システム変数$=がnilでない時には大文字小文字を区
        別せずに比較を行なう.

   self =~ other

        文字列のマッチ. otherは正規表現か文字列. otherが文字列の場合に
        は動的に正規表現に変換される. マッチした場合はマッチした位置, 
        しなかった場合はnilが返る.

   ~ self

        「$_ =~ self」と同義.

   self[nth]
   self[beg..end]
   self[beg,len]

        内容の取り出し. 1番目の形式ではnthバイト目のデータをFixnumとし
        て返す. 2番目の形式ではbegバイト目からendバイト目までの部分文
        字列を返す(両端を含む). 3番目の形式ではbegバイト目からlenバイ
        ト分の部分文字列を返す.

   self[nth] = val
   self[beg..end] = val
   self[beg,len] = val

        内容の更新. 1番目の形式ではnthバイト目のデータをval (整数)に変
        更する. 2番目の形式はbegバイト目からendバイト目までの部分文字
        列をvalとして与えられた文字列で置き換える. 3番目の形式はbegバ
        イト目からlenバイト分の部分文字列をvalとして与えられた文字列で
        置き換える.

   chop

        文字列の最後のバイトを切り落とす.

   crypt(salt)

        crypt(3)を用いて暗号化した文字列を返す. saltは2バイト以上の長
        さの任意の文字列である.

   delete(str)

	文字列のうち, strに含まれる文字を削除する. 文字列の指定はtrと
	同様であり, a-bでaからbまでの範囲を, 先頭の^で文字列の否定(含
	まれてないものを指定)を意味する.

   each

        文字列から1行ずつ読み込んでくるイテレータ.

   each_byte

        文字列のそれぞれのバイトについて繰り返すイテレータ.

   gsub(pattern, replace)

        文字列中でpatternにマッチする部分を全てreplaceに置き換える. 置
        換文字列replace中の&と\0はマッチした文字列に, \1..\9はn番目の
        括弧の内容に置き換えられる.

   hex

        文字列を16進数を表す文字列と解釈して, 整数に変換する.

   index(substr[, pos])

        substrが最初に出現する位置を返す. posを与えるとその位置から検
        索を開始する. 見つからない時にはnilを返す.

   intern

	文字列に一意に対応する整数を返す. 文字列はナル文字を含んではな
	らない.

   lcfirst

	文字列中の最初の文字を(それがアルファベットであれば), 小文字に
	変換する.

   length

        文字列の長さ(バイト数)を返す.

   next

        「次の」文字列を返す. 次の文字列とは数字は数字として,英文字は
        英文字として増加し, 桁上がりの処理が行なわれた者である.

                "aa".next == "ab"
                "99".next == "100"
                "a9".next == "b0"

        このメソッドはRange:eachで用いられているので, 以下のような処理
        が可能である.

                for i in "a" .. "ba"
                  print(i, "\n");
                end

        これはa, b, c, .. aa, .. az, baまでを各行に出力する.
        

        気を付けなければいけないのは, この終了判定は大小関係ではなく
        `=='で判定されているため, `..'演算子の左辺の値に続く文字列に右
        辺の文字列が含まれていない, 以下の例のような場合は無限ループに
        陥ってしまう.

                for i in "0" .. "1a"
                  print(i, "\n");
                end

        作者はこう書くことによって責任を逃れてようとしていると考える人
        もいるかもしれない. その推測は正しい.

   oct

        文字列を8進数を表す文字列と解釈して, 整数に変換する.  8進数の
        定義は/[0-7]+/であり, この定義に当てはまらない文字列に対しては
        0を返す. perlとは違って文字列が0xから始まっているからといって
        16進数だと見なしてくれたりはしない. それらは8進数ではないので0
        を返す.

   reverse

        文字列の各バイトを逆順に並べた文字列を返す. 文字列が2バイトで
        構成される文字を含んでいてもお構いなしにバイト単位で反転する. 
        splitは2バイト文字を理解するので, 2バイト文字を含む文字列を文
        字単位に反転するには

                "全角文字列".split(//).reverse.join("")

        とすればよい.

   rindex(substr[, pos])

        文字列substrが最後に出現する位置を返す. posを与えるとその位置
        で検索を終了する. 見つからない時にはnilを返す. indexとの相違点
        は1)文字列の末尾から検索する. 2)substrとして正規表現を受け付け
        ない. の2点である.

   split([sep[, limit]])

        文字列をsepで指定されたパターンによって, フィールドに分割する.
        sepが省略された時のデフォルトはシステム変数`$;'の値が用いられ
        る. limitが指定された時には最大limit個のフィールドに分割する.
        split()は分割された文字列を含む配列を返す. sepで指定されたパター
        ンが空文字列とマッチする場合は文字列が1文字ずつに分割される.

   squeeze([str])

	文字列のうち, strに含まれる文字が連続していた場合, 一文字に圧
	縮する. strが省略された場合, すべての文字を対象とする. 文字列
	の指定はtrと同様であり, `a-b'でaからbまでの範囲を, 先頭の`^'で
	文字列の否定(含まれてないものを指定)を意味する.

   strip

	文字列の前後の空白を取り除く.

   sub(pattern, replace)

        文字列中でpatternにマッチする部分をreplaceに置き換える. 置換文
        字列replace中の&と\0はマッチした文字列に, \1..\9はn番目の括弧
        の内容に置き換えられる. sub()はgsub()と異なり, 最初のマッチだ
        けを置換する.

   to_f

        文字列をFloatに変換する.

   to_i

        文字列を10進数を表す文字列と解釈して, 整数に変換する.

   toupper
   uc

        文字列中のアルファベットを全て大文字に置き換える. 元の文字列が
        更新されることに注意. tr("a-z", "A-Z")より少し速い.

   tolower
   lc

        文字列中のアルファベットを全て小文字に置き換える. 元の文字列が
        更新されることに注意. tr("A-Z", "a-z")より少し速い.

   tr(search, replace)

        文字列の中にsearch文字列に含まれる文字が存在すれば, replace文
        字列の対応する文字で置き換える. replace文字列が省略された場合
        は空文字列が与えられたと見なす. replace文字列がsearch文字列よ
        りも短い時はreplace文字列の最後の文字が繰り返されていると見な
        す. search文字列の方が短い時には対応する文字のないreplace部は
        単に無視される(BSDのtrの動作).

	search文字列, replace文字列中に`a-b'という形式が現れた場合, そ
	のaからbまでの範囲の文字をASCIIの昇順で指定したことになる.  ま
	た, search文字列の最初の文字が`^'である場合, 続く文字列に*含ま
	れない*文字列が置換の対象になる.

	tr(1)の機能のうち, 文字を削除する機能, 連続する文字を圧縮する
	機能は別のメソッドに分割されている. それらの機能については
	delete, squeezeを参照のこと.

	簡便のため, str.tr(src,repl).squeeze(repl)に相当するメソッド
	tr_s(src,repl) が提供されている.

   ucfirst

	文字列中の最初の文字を(それがアルファベットであれば), 大文字に
	変換する.

   unpack(template)

        文字列をtemplate文字列にしたがってアンパックし, それらの要素を
        含む配列を返す. template文字列はArrayクラスのpackメソッドとほ
        ぼ同様である.

          a     ASCII文字列(後続するnull文字やスペースを残す)
          A     ASCII文字列(後続するnull文字やスペースを削除)
          b     ビットストリング(下位ビットから上位ビット)
          B     ビットストリング(上位ビットから下位ビット)
          h     16進文字列(下位ニブルが先)
          H     16進文字列(上位ニブルが先)
          c     char
          C     unsigned char
          s     sort
          S     unsigned sort
          i     int
          I     unsigned int
          l     long
          L     unsigned int
          n     ネットワークバイトオーダーのshort
          N     ネットワークバイトオーダーのlong
          f     単精度浮動小数点数(機種依存)
          d     倍精度浮動小数点数(機種依存)
          x     1バイト読み飛ばす
          X     1バイト後退
          @     絶対位置への移動

Single Methods:

   new(string)

	stringと同じ内容を持つ新しい文字列を返す.

*** Struct(クラス)

構造体クラス. 複数のデータをまとめる時に用いられる(例: Time::times). 
データをまとめる時には配列クラスが用いられることもあるが(例: select),
構造体を使うべき時は以下のような場合である.

  (1) 要素の数が多い

      人間が一度に容易に扱える概念の数は7つまでであるという仮説がある. 
      この仮説に従えば, データが4つ以上の場合は配列を用いた場合, 要素
      数*2(つまりオフセットとその意味)が7を越える. よって, そのような
      場合には構造体を使った方が理解しやすいと思われる.

  (2) 同時に大量に生成されない

      構造体は配列よりも若干生成コストが高いので, 速度が問題になる場合
      には, (同時に大量に生成される場合など)は構造体の使用が適切でない
      可能性がある.

各構造体にはメンバ名と同名の引数のないメソッドが定義されている.

本ドキュメント内で, 構造体を表現するためには以下の形式を使う.

  struct 構造体名
    メンバ ...
  end

しかし, プログラム中でこの形式で構造体を生成するわけではない.

SuperClass: Object

Included Modules: Enumerable

Methods:

   self[idx]

	idxが数の時はidx番目の要素を返す. idxが文字列の時はidxと同じ名
	前のメンバの要素を返す.

   values

	構造体のメンバの値を要素に持つ配列を返す. 例えば以下のコードで
	自分のpasswdエントリを出力することができる.

	  print(Etc.getpwuid().values.join(":"), "\n")

	この出力は`grep "$USER" /etc/passwd'の出力と余分なフィールドい
	くつか(システムによって異なる)がある以外は同じである.

Single Methods:

   new(name, member::value...)

	nameという名前を持つ構造体を生成する. memberは構造体のメンバを
	表す文字列であり, valueはその値である. 生成された構造体はメン
	バで指定された名前の特異メソッドが定義されていて, そのメソッド
	によってメンバの内容を得ることができる.

*** TCPserver(クラス)

TCP/IPストリーム型接続のサーバ側のソケットのクラス. このクラスによって
簡単にソケットを利用したサーバのプログラミングができる. 例えばechoサー
バは以下のようになる.

 gs = TCPserver.open(4444)
 socks = [gs]

 while %TRUE
   nsock = select(socks);
   if nsock == nil; continue end
   for s in nsock[0]
     if s == gs
       socks.push(s.accept)
     else
       if s.eof
 	 s.close
	 socks.delete(s)
       else
	 str = s.gets
	 s.write(str)
       end
     end
   end
 end

SuperClass: TCPsocket

Methods:

   accept

	クライアントからの接続要求を受け付け, 接続したTCPsocketのイン
	スタンスを返す.

Single Methods:

   new([host, ]service)
   open([host, ]service)

	serviceは/etc/services(またはNIS)に登録されているサービス名か
	ポート番号で指定する. hostを指定した時は指定したホストからの接
	続だけを受け付ける. 省略時は全てのホストからの接続要求を受け付
	ける.

*** TCPsocket

インターネットドメインのストリーム型ソケットのクラス. 通常のIOクラスの
サブクラスと同様の入出力ができる. このクラスによってソケットを用いたク
ライアントを簡単に記述できる. ユーザの入力をそのままサーバに転送するプ
ログラムは以下のようになる.

 s = TCPsocket("localhost", 4444)
 while gets()
   s.write($_)
   print(s.read)
 end

SuperClass: BasicSocket

Methods:

   addr

	ソケットの接続情報を表す配列を返す. その配列の各要素は第1要素
	が文字列 "AF_INET", 第2要素がport番号, 第3要素がホストを表す文
	字列である.

   peeraddr

	接続相手先ソケットの情報を表す配列を返す. その配列の各要素は
	addrメソッドが返す配列と同じである.

Single Methods:

   open(host, service)
   new(host, service)

	hostで指定したホストのserviceで指定したポートと接続したソケッ
	トを返す. hostはホスト名, またはインターネットアドレスを示す文
	字列, serviceは/etc/services(またはNIS)に登録されているサービ
	ス名かポート番号である.

*** Time(クラス)

時間を表すクラス. 大小比較などができる. Time.nowで現在の時間を得ること
ができる. またファイルのタイムスタンプを得るメソッドの戻り値もこのクラ
スのインスタンスである.

SuperClass: Object

Included Modules: Comparable

Methods:

   self == other
   self > other

        otherはTimeのインスタンスか整数. 整数が与えられた場
        合には1970年 1月 1日 00:00:00 GMTからの秒数であると
        して時刻との比較を行なう.

   asctime
   ctime
   to_s

        時刻をdate(1)形式の文字列に変換する.

   gmtime

        タイムゾーンの修正を行なわないGMTでの時刻を得る. このメソッド
        を受けとったTimeクラスのインスタンスは, 以後の時刻変換をGMTで
        行なう. gmtimeは自分自身を返す.

	ロンドンの時刻を表示するには

	  print(Time.now.gmtime, "\n")

	とすればよい.

   localtime

        タイムゾーンの修正を行なった時刻を得る(デフォルト). localtime
        も自分自身を返す.

   to_i
   tv_sec

        1970年 1月 1日 00:00:00 GMTから時刻までの秒数を整数で返す. 時
        刻のsecondの部分でもある.

   sec
   min
   hour
   mday
   year
   wday
   yday
   zone
   isdst

        内部的に保持しているtm構造体の内容を返す. zone以外は整数を返す. 
        zoneはタイムゾーンを表す文字列を返す. (cf localtime(3))

   strftime(format)

        時刻をformat文字列に従って文字列に変換した結果を返す.  format
        文字列として指定できるものは 以下の通りである.

                %A      曜日の名称(Sunday, Monday,...)
                %a      曜日の省略名(Sun, Mon,...)
                %B      月の名称(January, February,...)
                %b      月の省略名(Jan, Feb,...)
                %c      時刻表現(cf ctime(3))
                %d      十進数での日(01-31)
                %H      24時間制の時(00-23)
                %I      12時間制の時(01-12)
                %j      年中の通算日(001-366)
                %M      分(00-59)
                %m      月を表す数字(01-12)
                %p      午前または午後(AM,PM)
                %S      秒(00-61)
                %U      週を表す数字. 最初の日曜日が第1週の
                        始まり(00-53)
                %W      週を表す数字. 最初の月曜日が第1週の
                        始まり(00-53)
                %w      曜日を表す数字. 日曜日が0(0-6)
                %X      時刻(例: 15:01:06)
                %x      日付(例: Fri Jan 14 1994)
                %Y      西暦を表す数字
                %y      西暦の下2桁(00-99)
                %Z      タイムゾーン
                %%      %自身 

   usec
   tv_usec

        時刻のmicro secondの部分を返す.

Single Methods:

   now

        現在の時刻を表すTimeクラスのインスタンスを生成する.

   at(time)

        timeと同じ時刻を表すTimeクラスのインスタンスを生成する. timeは
        Timeクラスのインスタンスかあるいは数(整数/浮動小数点数)であり, 
        数の場合は1970年 1月 1日 00:00:00 GMTからの秒数であるとして時
        刻を計算する.

   times

        現在のプロセスとその子プロセスが消費したユーザ/システムCPUタイ
        ムの積算を構造体として返す(Structを参照).

	  struct tms
	    utime	# プロセスのユーザ時間
	    stime	# プロセスのシステム時間
	    cutime	# 子プロセスのユーザ時間
	    cstime	# 子プロセスのシステム時間
	  end

	時間の単位は秒であり, 浮動小数点数で与えられる. 詳細は
        times(3C)を参照のこと.

*** UNIXserver

UNIXストリーム型接続のサーバ側のソケットのクラス.

SuperClass: UNIXsocket

Methods:

   accept

	クライアントからの接続要求を受け付け, 接続したUNIXsocketのイン
	スタンスを返す.

*** UNIXsocket

UNIXドメインのストリーム型ソケットのクラス. 通常のIOクラスのサブクラス
と同様の入出力ができる.

SuperClass: BasicSocket

Methods:

   addr

	ソケットの接続情報を表す配列を返す. その配列の各要素は第1要素
	が文字列 "AF_UNIX", 第2要素がpathである.

   path

	UNIXソケットのパスを返す.

   peeraddr

	接続相手先ソケットの情報を表す配列を返す. その配列の各要素は
	addrメソッドが返す配列と同じである.

Single Methods:

   open(path)
   new(path)

	pathで指定したパス名を用いて接続したソケットを返す.

-------------------------------------------------------
Local variables:
fill-column: 70
end:
